<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Guidelines for HTTP-to-CoAP Mapping Implementations </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology"/>
<link href="#rfc.section.3" rel="Chapter" title="3 HTTP-to-CoAP Proxy"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Use Cases"/>
<link href="#rfc.section.5" rel="Chapter" title="5 URI Mapping"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 URI Terminology"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Null Mapping"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Default Mapping"/>
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Optional Scheme Omission"/>
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 Encoding Caveats"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 URI Mapping Template"/>
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 Simple Form"/>
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 Enhanced Form"/>
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Discovery"/>
<link href="#rfc.section.5.5.1" rel="Chapter" title="5.5.1 Examples"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Media Type Mapping"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Overview"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 'application/coap-payload' Media Type"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Loose Media Type Mapping"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Media Type to Content Format Mapping Algorithm"/>
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Content Transcoding"/>
<link href="#rfc.section.6.5.1" rel="Chapter" title="6.5.1 General"/>
<link href="#rfc.section.6.5.2" rel="Chapter" title="6.5.2 CoRE Link Format"/>
<link href="#rfc.section.6.5.3" rel="Chapter" title="6.5.3 Diagnostic Messages"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Response Code Mapping"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Additional Mapping Guidelines"/>
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Caching and Congestion Control"/>
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Cache Refresh via Observe"/>
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Use of CoAP Blockwise Transfer"/>
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 CoAP Multicast"/>
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 Timeouts"/>
<link href="#rfc.section.9" rel="Chapter" title="9 IANA Considerations"/>
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 New 'core.hc' Resource Type"/>
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 New 'coap-payload' Internet Media Type"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations"/>
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Multicast"/>
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Traffic Overflow"/>
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Handling Secured Exchanges"/>
<link href="#rfc.section.10.4" rel="Chapter" title="10.4 URI Mapping"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Acknowledgments"/>
<link href="#rfc.references" rel="Chapter" title="12 References"/>
<link href="#rfc.references.1" rel="Chapter" title="12.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="12.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Media Type Mapping Source Code"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Change Log"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Castellani, A., Loreto, S., Rahman, A., Fossati, T., and E. Dijk" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-core-http-mapping-17" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-11-27" />
  <meta name="dct.abstract" content="This document provides reference information for implementing a cross-protocol network proxy that performs translation from the HTTP protocol to CoAP (Constrained Application Protocol).  This will enable an HTTP client to access resources on a CoAP server through the proxy.  This document describes how an HTTP request is mapped to a CoAP request, and then how a CoAP response is mapped back to an HTTP response.  This includes guidelines for status code, URI, and media type mappings, as well as additional interworking advice." />
  <meta name="description" content="This document provides reference information for implementing a cross-protocol network proxy that performs translation from the HTTP protocol to CoAP (Constrained Application Protocol).  This will enable an HTTP client to access resources on a CoAP server through the proxy.  This document describes how an HTTP request is mapped to a CoAP request, and then how a CoAP response is mapped back to an HTTP response.  This includes guidelines for status code, URI, and media type mappings, as well as additional interworking advice." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">CoRE Working Group</td>
  <td class="right">A. Castellani</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">University of Padova</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">S. Loreto</td>
</tr>
<tr>
  <td class="left">Expires: May 31, 2017</td>
  <td class="right">Ericsson</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">A. Rahman</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">InterDigital Communications, LLC</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">T. Fossati</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">Nokia</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">E. Dijk</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">Philips Lighting</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">November 27, 2016</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Guidelines for HTTP-to-CoAP Mapping Implementations <br />
  <span class="filename">draft-ietf-core-http-mapping-17</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document provides reference information for implementing a cross-protocol network proxy that performs translation from the HTTP protocol to CoAP (Constrained Application Protocol).  This will enable an HTTP client to access resources on a CoAP server through the proxy.  This document describes how an HTTP request is mapped to a CoAP request, and then how a CoAP response is mapped back to an HTTP response.  This includes guidelines for status code, URI, and media type mappings, as well as additional interworking advice.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 31, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Terminology</a></li>
<li>3.   <a href="#rfc.section.3">HTTP-to-CoAP Proxy</a></li>
<li>4.   <a href="#rfc.section.4">Use Cases</a></li>
<li>5.   <a href="#rfc.section.5">URI Mapping</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">URI Terminology</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Null Mapping</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Default Mapping</a></li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">Optional Scheme Omission</a></li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">Encoding Caveats</a></li>
</ul><li>5.4.   <a href="#rfc.section.5.4">URI Mapping Template</a></li>
<ul><li>5.4.1.   <a href="#rfc.section.5.4.1">Simple Form</a></li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">Enhanced Form</a></li>
</ul><li>5.5.   <a href="#rfc.section.5.5">Discovery</a></li>
<ul><li>5.5.1.   <a href="#rfc.section.5.5.1">Examples</a></li>
</ul></ul><li>6.   <a href="#rfc.section.6">Media Type Mapping</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Overview</a></li>
<li>6.2.   <a href="#rfc.section.6.2">'application/coap-payload' Media Type</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Loose Media Type Mapping</a></li>
<li>6.4.   <a href="#rfc.section.6.4">Media Type to Content Format Mapping Algorithm</a></li>
<li>6.5.   <a href="#rfc.section.6.5">Content Transcoding</a></li>
<ul><li>6.5.1.   <a href="#rfc.section.6.5.1">General</a></li>
<li>6.5.2.   <a href="#rfc.section.6.5.2">CoRE Link Format</a></li>
<li>6.5.3.   <a href="#rfc.section.6.5.3">Diagnostic Messages</a></li>
</ul></ul><li>7.   <a href="#rfc.section.7">Response Code Mapping</a></li>
<li>8.   <a href="#rfc.section.8">Additional Mapping Guidelines</a></li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Caching and Congestion Control</a></li>
<li>8.2.   <a href="#rfc.section.8.2">Cache Refresh via Observe</a></li>
<li>8.3.   <a href="#rfc.section.8.3">Use of CoAP Blockwise Transfer</a></li>
<li>8.4.   <a href="#rfc.section.8.4">CoAP Multicast</a></li>
<li>8.5.   <a href="#rfc.section.8.5">Timeouts</a></li>
</ul><li>9.   <a href="#rfc.section.9">IANA Considerations</a></li>
<ul><li>9.1.   <a href="#rfc.section.9.1">New 'core.hc' Resource Type</a></li>
<li>9.2.   <a href="#rfc.section.9.2">New 'coap-payload' Internet Media Type</a></li>
</ul><li>10.   <a href="#rfc.section.10">Security Considerations</a></li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Multicast</a></li>
<li>10.2.   <a href="#rfc.section.10.2">Traffic Overflow</a></li>
<li>10.3.   <a href="#rfc.section.10.3">Handling Secured Exchanges</a></li>
<li>10.4.   <a href="#rfc.section.10.4">URI Mapping</a></li>
</ul><li>11.   <a href="#rfc.section.11">Acknowledgments</a></li>
<li>12.   <a href="#rfc.references">References</a></li>
<ul><li>12.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>12.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Media Type Mapping Source Code</a></li>
<li>Appendix B.   <a href="#rfc.appendix.B">Change Log</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">CoAP (Constrained Application Protocol) <a href="#RFC7252">[RFC7252]</a> has been designed with the twofold aim to be an application protocol specialized for constrained environments and to be easily used in Representational State Transfer (REST) <a href="#Fielding">[Fielding]</a> based architectures such as the Web.  The latter goal has led to defining CoAP to easily interoperate with HTTP <a href="#RFC7230">[RFC7230]</a> through an intermediary proxy which performs cross-protocol conversion.</p>
<p id="rfc.section.1.p.2">Section 10 of <a href="#RFC7252">[RFC7252]</a> describes the fundamentals of the CoAP-to-HTTP and the HTTP-to-CoAP cross-protocol mapping process.  However, <a href="#RFC7252">[RFC7252]</a> focuses on the basic mapping of request methods and simple response code mapping between HTTP and CoAP, while leaving many details of the cross-protocol proxy for future definition.  Therefore, a primary goal of this document is to define a consistent set of guidelines that an HTTP-to-CoAP proxy implementation should adhere to. The key benefit to adhering to such guidelines is to reduce variation between proxy implementations, thereby increasing interoperability between an HTTP client and a CoAP server independent of the proxy that implements the cross-protocol mapping. (For example, a proxy conforming to these guidelines made by vendor A can be easily replaced by a proxy from vendor B that also conforms to the guidelines without breaking API semantics.)</p>
<p id="rfc.section.1.p.3">This document describes HTTP mappings that apply to protocol elements defined in the base CoAP specification <a href="#RFC7252">[RFC7252]</a>.  It is up to CoAP protocol extensions (new methods, response codes, options, content-formats) to describe their own HTTP mappings, if applicable.</p>
<p id="rfc.section.1.p.4">The rest of this document is organized as follows: </p>

<ul>
  <li><a href="#terminology">Section 2</a> defines proxy terminology;</li>
  <li><a href="#hc">Section 3</a> introduces the HTTP-to-CoAP proxy;</li>
  <li><a href="#usecases">Section 4</a> lists use cases in which HTTP clients need to contact CoAP servers;</li>
  <li><a href="#URI-mapping">Section 5</a> introduces a null, default, and advanced HTTP-to-CoAP URI mapping syntax;</li>
  <li><a href="#hc-media">Section 6</a> describes how to map HTTP media types to CoAP content formats and vice versa;</li>
  <li><a href="#hc-resp">Section 7</a> describes how to map CoAP responses to HTTP responses;</li>
  <li><a href="#hc-additional">Section 8</a> describes additional mapping guidelines related to caching, congestion, timeouts, etc.;</li>
  <li><a href="#sec">Section 10</a> discusses possible security impact of HTTP-to-CoAP protocol mapping.</li>
</ul>

<p> </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#terminology" id="terminology">Terminology</a></h1>
<p id="rfc.section.2.p.1">The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.2.p.2">This specification requires readers to be familiar with the vocabulary and concepts discussed in <a href="#RFC7228">[RFC7228]</a>, in particular, the terms "Constrained Nodes" and "Constrained Networks".  In addition, this specification makes use of the following terms: </p>

<dl>
  <dt>HC Proxy</dt>
  <dd style="margin-left: 4"><br/>A proxy performing a cross-protocol mapping, in the context of this document an HTTP-to-CoAP (HC) mapping. Specifically, the HC Proxy acts as an HTTP server and a CoAP client.  The HC Proxy can take on the role of a Forward, Reverse or Interception Proxy.</dd>
  <dt>Forward Proxy (or Forward HC Proxy)</dt>
  <dd style="margin-left: 4"><br/>A message forwarding agent that is selected by the HTTP client, usually via local configuration rules, to receive requests for some type(s) of absolute URI and to attempt to satisfy those requests via translation to the protocol indicated by the absolute URI.  The user decides (is willing) to use the proxy as the forwarding/de-referencing agent for a predefined subset of the URI space. In <a href="#RFC7230">[RFC7230]</a> this is called a Proxy.  <a href="#RFC7252">[RFC7252]</a> defines Forward-Proxy similarly.</dd>
  <dt>Reverse Proxy (or Reverse HC Proxy)</dt>
  <dd style="margin-left: 4"><br/>As in <a href="#RFC7230">[RFC7230]</a>, a receiving agent that acts as a layer above some other server(s) and translates the received requests to the underlying server's protocol.  A Reverse HC Proxy behaves as an origin (HTTP) server on its connection from the HTTP client.  The HTTP client uses the "origin-form" (Section 5.3.1 of <a href="#RFC7230">[RFC7230]</a>) as a request-target URI.  (Note that a Reverse Proxy appears to an HTTP client as an origin server while a Forward Proxy does not. So, when communicating with a Reverse Proxy a client may be unaware it is communicating with a proxy at all.)</dd>
  <dt>Interception Proxy (or Interception HC Proxy)</dt>
  <dd style="margin-left: 4"><br/>As in <a href="#RFC3040">[RFC3040]</a>, a proxy that receives inbound HTTP traffic flows through the process of traffic redirection, transparent to the HTTP client.</dd>
</dl>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#hc" id="hc">HTTP-to-CoAP Proxy</a></h1>
<p id="rfc.section.3.p.1">An HC Proxy is accessed by an HTTP client that needs to fetch a resource on a CoAP server.  The HC Proxy handles the HTTP request by mapping it to the equivalent CoAP request, which is then forwarded to the appropriate CoAP server.  The received CoAP response is then mapped to an appropriate HTTP response and finally sent back to the originating HTTP client.</p>
<div id="rfc.figure.1"/>
<div id="fig-http-coap-deployment"/>
<pre>
            
                                            Constrained Network
                                           .-------------------.
                                          /      .------.       \
                                         /       | CoAP |        \
                                        /        |server|         \
                                       ||        '------'         ||
                                       ||                         ||
  .--------.  HTTP Request   .------------.  CoAP Req  .------.   ||
  |  HTTP  |----------------&gt;|HTTP-to-CoAP|-----------&gt;| CoAP |   ||
  | Client |&lt;----------------|   Proxy    |&lt;-----------|Server|   ||
  '--------'  HTTP Response  '------------'  CoAP Resp '------'   ||
                                       ||                         ||
                                       ||   .------.              ||
                                       ||   | CoAP |              ||
                                        \   |server|  .------.    /
                                         \  '------'  | CoAP |   /
                                          \           |server|  /
                                           \          '------' /
                                            '-----------------'
            
          </pre>
<p class="figure">Figure 1: HTTP-To-CoAP Proxy Deployment Scenario</p>
<p><a href="#fig-http-coap-deployment">Figure 1</a> illustrates an example deployment scenario. There, an HC Proxy is located at the boundary of the Constrained Network domain and acts as an Application Layer Gateway (ALG) that allows only a very specific type of traffic (i.e., authorized inbound HTTP requests and their associated outbound CoAP responses) to pass through.  All other kinds of traffic are segregated within the respective network segments.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#usecases" id="usecases">Use Cases</a></h1>
<p id="rfc.section.4.p.1">To illustrate a few situations in which HTTP to CoAP protocol translation may be used, three use cases are described below.  </p>

<ol>
  <li>Legacy building control application without CoAP: A building control application that uses HTTP but not CoAP can check the status of CoAP sensors and/or control actuators via an HC Proxy.</li>
  <li>Making sensor data available to 3rd parties on the Web: For demonstration or public interest purposes, an HC Proxy may be configured to expose the contents of a CoAP sensor to the world via the web (HTTP and/or HTTPS).  Some sensors may only accept secure 'coaps' requests, therefore the proxy is configured to translate requests to those devices accordingly.  The HC Proxy is furthermore configured to only pass through GET requests in order to protect the constrained network.</li>
  <li>Smartphone and home sensor: A smartphone can access directly a CoAP home sensor using a mutually authenticated 'https' request, provided its home router runs an HC Proxy and is configured with the appropriate certificate.  An HTML5 <a href="#W3C.REC-html5-20141028">[W3C.REC-html5-20141028]</a> application on the smartphone can provide a friendly UI using the standard (HTTP) networking functions of HTML5.</li>
</ol>

<p> </p>
<p id="rfc.section.4.p.2">A key point in the above use cases is the expected nature of the URI to be used by the HTTP client initiating the HTTP request to the HC Proxy.  Specifically, in use case #1, there will be no 'coap' or 'coaps' related information embedded in the HTTP URI as it is a legacy HTTP client sending the request.  Use case #2 is also expected to be similar.  In contrast, in use case #3, it is likely that the HTTP client will specifically embed 'coap' or 'coaps' related information in the HTTP URI of the HTTP request to the HC Proxy.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#URI-mapping" id="URI-mapping">URI Mapping</a></h1>
<p id="rfc.section.5.p.1">Though, in principle, a CoAP URI could be directly used by an HTTP client to de-reference a CoAP resource through an HC Proxy, the reality is that all major web browsers, networking libraries and command line tools do not allow making HTTP requests using URIs with a scheme 'coap' or 'coaps'.</p>
<p id="rfc.section.5.p.2">Thus, there is a need for web applications to embed or "pack" a CoAP URI into an HTTP URI so that it can be (non-destructively) transported from the HTTP client to the HC Proxy.  The HC Proxy can then "unpack" the CoAP URI and finally de-reference it via a CoAP request to the target Server.</p>
<p id="rfc.section.5.p.3">URI Mapping is the term used in this document to describe the process through which the URI of a CoAP resource is transformed into an HTTP URI so that: </p>

<ul>
  <li>The requesting HTTP client can handle it;</li>
  <li>The receiving HC Proxy can extract the intended CoAP URI unambiguously.</li>
</ul>

<p> </p>
<p id="rfc.section.5.p.4">To this end, the remainder of this section will identify: </p>

<ul>
  <li>The default mechanism to map a CoAP URI into an HTTP URI;</li>
  <li>The URI template format to express a class of CoAP-HTTP URI mapping functions;</li>
  <li>The discovery mechanism based on CoRE Link Format <a href="#RFC6690">[RFC6690]</a> through which clients of an HC Proxy can dynamically learn about the supported URI Mapping Template(s), as well as the URI where the HC Proxy function is anchored.</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> URI Terminology</h1>
<p id="rfc.section.5.1.p.1">In the remainder of this section, the following terms will be used with a distinctive meaning: </p>

<dl>
  <dt>HC Proxy URI:</dt>
  <dd style="margin-left: 8"><br/>URI which refers to the HC Proxy function.  It conforms to syntax defined in Section 2.7 of <a href="#RFC7230">[RFC7230]</a>.</dd>
  <dt>Target CoAP URI:</dt>
  <dd style="margin-left: 8"><br/>URI which refers to the (final) CoAP resource that has to be de-referenced.  It conforms to syntax defined in Section 6 of <a href="#RFC7252">[RFC7252]</a>.  Specifically, its scheme is either 'coap' or 'coaps'.</dd>
  <dt>Hosting HTTP URI:</dt>
  <dd style="margin-left: 8"><br/>URI that conforms to syntax in Section 2.7 of <a href="#RFC7230">[RFC7230]</a>.  Its authority component refers to an HC Proxy, whereas path and/or query component(s) embed the information used by an HC Proxy to extract the Target CoAP URI.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#section.null-mapping" id="section.null-mapping">Null Mapping</a></h1>
<p id="rfc.section.5.2.p.1">The null mapping is the case where there is no Target CoAP URI appended to the HC Proxy URI.  In other words, it is a "pure" HTTP URI that is sent to the HC Proxy.  This would typically occur in situations like Use Case #1 described in <a href="#usecases">Section 4</a>, and the Proxy would typically be a Reverse Proxy. In this scenario, the HC Proxy will determine through its own private algorithms what the Target CoAP URI should be.</p>
<h1 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#section.default-mapping" id="section.default-mapping">Default Mapping</a></h1>
<p id="rfc.section.5.3.p.1">The default mapping is for the Target CoAP URI to be appended as-is (with the only caveat discussed in <a href="#section.encoding-caveats">Section 5.3.2</a>) to the HC Proxy URI, to form the Hosting HTTP URI.  This is the Effective Request URI (see Section 5.5 of <a href="#RFC7230">[RFC7230]</a>) that will then be sent by the HTTP client in the HTTP request to the HC Proxy.</p>
<p id="rfc.section.5.3.p.2">For example: given an HC Proxy URI https://p.example.com/hc/ and a Target CoAP URI coap://s.example.com/light, the resulting Hosting HTTP URI would be https://p.example.com/hc/coap://s.example.com/light.</p>
<p id="rfc.section.5.3.p.3">Provided a correct Target CoAP URI, the Hosting HTTP URI resulting from the default mapping will be a syntactically valid HTTP URI.  Furthermore, the Target CoAP URI can always be extracted unambiguously from the Hosting HTTP URI.</p>
<p id="rfc.section.5.3.p.4">There is no default for the HC Proxy URI.  Therefore, it is either known in advance, e.g., as a configuration preset, or dynamically discovered using the mechanism described in <a href="#section.discovery">Section 5.5</a>.</p>
<p id="rfc.section.5.3.p.5">The default URI mapping function SHOULD be implemented and SHOULD be activated by default in an HC Proxy, unless there are valid reasons (e.g., application specific) to use a different mapping function.</p>
<h1 id="rfc.section.5.3.1"><a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#section.optional-scheme" id="section.optional-scheme">Optional Scheme Omission</a></h1>
<p id="rfc.section.5.3.1.p.1">When constructing a Hosting HTTP URI by embedding a Target CoAP URI, the scheme (i.e., 'coap' or 'coaps'), the scheme component delimiter (":"), and the double slash ("//") preceding the authority MAY be omitted if a local default - not defined by this document - applies.  If no prior mutual agreement exists between the client and the HC Proxy, then a Target CoAP URI without the scheme component is syntactically incorrect, and therefore: </p>

<ul>
  <li>It MUST NOT be emitted by clients;</li>
  <li>It MUST elicit a suitable client error status (i.e., 4xx) by the HC Proxy.</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.3.2"><a href="#rfc.section.5.3.2">5.3.2.</a> <a href="#section.encoding-caveats" id="section.encoding-caveats">Encoding Caveats</a></h1>
<p id="rfc.section.5.3.2.p.1">When the authority of the Target CoAP URI is given as an IPv6address, then the surrounding square brackets must be percent-encoded in the Hosting HTTP URI, in order to comply with the syntax defined in Section 3.3. of <a href="#RFC3986">[RFC3986]</a> for a URI path segment.  E.g.: coap://[2001:db8::1]/light?on becomes https://p.example.com/hc/coap://%5B2001:db8::1%5D/light?on.  (Note that the percent-encoded square brackets shall be reverted to their non-percent-encoded form when the HC Proxy unpacks the Target CoAP URI.)</p>
<p id="rfc.section.5.3.2.p.2">Everything else can be safely copied verbatim from the Target CoAP URI to the Hosting HTTP URI.</p>
<h1 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> URI Mapping Template</h1>
<p id="rfc.section.5.4.p.1">This section defines a format for the URI template <a href="#RFC6570">[RFC6570]</a> used by an HC Proxy to inform its clients about the expected syntax for the Hosting HTTP URI.  This will then be used by the HTTP client to construct the Effective Request URI to be sent in the HTTP request to the HC Proxy.</p>
<p id="rfc.section.5.4.p.2">When instantiated, aURI Mapping Template is always concatenated to an HC Proxy URI provided by the HC Proxy via discovery (see <a href="#section.discovery">Section 5.5</a>), or by other means.</p>
<p id="rfc.section.5.4.p.3">A simple form (<a href="#section.simple-form">Section 5.4.1</a>) and an enhanced form (<a href="#section.enhanced-form">Section 5.4.2</a>) are provided to fit different users' requirements.</p>
<p id="rfc.section.5.4.p.4">Both forms are expressed as level 2 URI templates <a href="#RFC6570">[RFC6570]</a> to take care of the expansion of values that are allowed to include reserved URI characters.  The syntax of all URI formats is specified in this section in Augmented Backus-Naur Form (ABNF) <a href="#RFC5234">[RFC5234]</a>.</p>
<h1 id="rfc.section.5.4.1"><a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#section.simple-form" id="section.simple-form">Simple Form</a></h1>
<p id="rfc.section.5.4.1.p.1">The simple form MUST be used for mappings where the Target CoAP URI is going to be copied (using rules of <a href="#section.encoding-caveats">Section 5.3.2</a>) at some fixed position into the Hosting HTTP URI.</p>
<pre>
                
    tu = [ ( "coap:" / "coaps:" ) "//" ] host [ ":" port ] path-abempty
         [ "?" query ]
                
              </pre>
<p id="rfc.section.5.4.1.p.2">The "tu" template variable is intended to be used in a template definition to represent a Target CoAP URI: </p>
<p id="rfc.section.5.4.1.p.3">Note that the same considerations as in <a href="#section.optional-scheme">Section 5.3.1</a> apply, in that the CoAP scheme may be omitted from the Hosting HTTP URI.</p>
<h1 id="rfc.section.5.4.1.1"><a href="#rfc.section.5.4.1.1">5.4.1.1.</a> Examples</h1>
<p id="rfc.section.5.4.1.1.p.1">All the following examples (given as a specific URI mapping template, a Target CoAP URI, and the produced Hosting HTTP URI) use https://p.example.com/hc/ as the HC Proxy URI.  Note that these examples all define mapping templates that deviate from the default template of <a href="#section.default-mapping">Section 5.3</a> in order to illustrate the use of the above template variables.</p>
<pre>
                      
?target_uri={+tu}

coap://s.example.com/light

=&gt; https://p.example.com/hc/?target_uri=coap://s.example.com/light

whereas

coaps://s.example.com/light

=&gt; https://p.example.com/hc/?target_uri=coaps://s.example.com/light
                      
                    </pre>
<pre>
                      
forward/{+tu}

coap://s.example.com/light

=&gt; https://p.example.com/hc/forward/coap://s.example.com/light

whereas

coaps://s.example.com/light

=&gt; https://p.example.com/hc/forward/coaps://s.example.com/light
                      
                    </pre>
<pre>
                      
?coap_uri={+tu}

coap://s.example.com/light

=&gt; https://p.example.com/hc/?coap_uri=s.example.com/light
                      
                    </pre>
<p/>

<ol>
  <li>Target CoAP URI is a query argument of the Hosting HTTP URI: </li>
  <li>Target CoAP URI in the path component of the Hosting HTTP URI: </li>
  <li>Target CoAP URI is a query argument of the Hosting HTTP URI; client decides to omit the scheme because a default is agreed beforehand between client and proxy: </li>
</ol>

<p> </p>
<h1 id="rfc.section.5.4.2"><a href="#rfc.section.5.4.2">5.4.2.</a> <a href="#section.enhanced-form" id="section.enhanced-form">Enhanced Form</a></h1>
<p id="rfc.section.5.4.2.p.1">The enhanced form can be used to express more sophisticated mappings of the Target CoAP URI into the Hosting HTTP URI, i.e., mappings that do not fit into the simple form.</p>
<pre>
                
    s  = "coap" / "coaps" ; from [RFC7252], Sections 6.1 and 6.2
    hp = host [":" port]  ; from [RFC3986], Sections 3.2.2 and 3.2.3
    p  = path-abempty     ; from [RFC3986], Section 3.3
    q  = query            ; from [RFC3986], Section 3.4 
    qq = [ "?" query ]    ; qq is empty if and only if 'query' is empty
                
              </pre>
<p id="rfc.section.5.4.2.p.2">There MUST be at most one instance of each of the following template variables in a template definition: </p>
<p id="rfc.section.5.4.2.p.3">The qq form is used when the path and the (optional) query components are to be copied verbatim from the Target CoAP URI into the Hosting HTTP URI, i.e., as "{+p}{+qq}".  Instead, the q form is used when the query and path are mapped as separate entities, e.g., as in "coap_path={+p}&amp;coap_query={+q}".</p>
<h1 id="rfc.section.5.4.2.1"><a href="#rfc.section.5.4.2.1">5.4.2.1.</a> Examples</h1>
<p id="rfc.section.5.4.2.1.p.1">All the following examples (given as a specific URI mapping template, a Target CoAP URI, and the produced Hosting HTTP URI) use https://p.example.com/hc/ as the HC Proxy URI.</p>
<pre>
                      
    {+s}/{+hp}{+p}{+qq}

    coap://s.example.com/light

    =&gt; https://p.example.com/hc/coap/s.example.com/light

    whereas

    coap://s.example.com/light?on

    =&gt; https://p.example.com/hc/coap/s.example.com/light?on
                      
                    </pre>
<pre>
                      
    ?s={+s}&amp;hp={+hp}&amp;p={+p}&amp;q={+q}

    coap://s.example.com/light

    =&gt; https://p.example.com/hc/?s=coap&amp;hp=s.example.com&amp;p=/light&amp;q=

    whereas

    coaps://s.example.com/light?on

    =&gt; https://p.example.com/hc/?s=coaps&amp;hp=s.example.com&amp;p=/light&amp;q=on
                      
                    </pre>
<p/>

<ol>
  <li>Target CoAP URI components in path segments, and optional query in query component: </li>
  <li>Target CoAP URI components split in individual query arguments: </li>
</ol>

<p> </p>
<h1 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a> <a href="#section.discovery" id="section.discovery">Discovery</a></h1>
<p id="rfc.section.5.5.p.1">In order to accommodate site-specific needs while allowing third parties to discover the proxy function, the HC Proxy SHOULD publish information related to the location and syntax of the HC Proxy function using the CoRE Link Format <a href="#RFC6690">[RFC6690]</a> interface.</p>
<p id="rfc.section.5.5.p.2">To this aim a new Resource Type, "core.hc", is defined in this document. It can be used as the value for the "rt" attribute in a query to the /.well-known/core in order to locate the URI where the HC Proxy function is anchored, i.e., the HC Proxy URI.</p>
<p id="rfc.section.5.5.p.3">Along with it, the new target attribute "hct" is defined in this document. This attribute MAY be returned in a "core.hc" link to provide the URI Mapping Template associated with the mapping resource.  The default template given in <a href="#section.default-mapping">Section 5.3</a>, i.e., {+tu}, MUST be assumed if no "hct" attribute is found in the returned link.  If a "hct" attribute is present in the returned link, then a client MUST use it to create the Hosting HTTP URI.</p>
<p id="rfc.section.5.5.p.4">The URI mapping SHOULD be discoverable (as specified in <a href="#RFC6690">[RFC6690]</a>) on both the HTTP and the CoAP side of the HC Proxy, with one important difference: on the CoAP side the link associated with the "core.hc" resource needs an explicit anchor referring to the HTTP origin <a href="#RFC6454">[RFC6454]</a>, while on the HTTP interface the link context is already the HTTP origin carried in the request's Host header, and doesn't have to be made explicit.</p>
<h1 id="rfc.section.5.5.1"><a href="#rfc.section.5.5.1">5.5.1.</a> Examples</h1>
<pre>
                    
    Req:  GET coap://[ff02::1]/.well-known/core?rt=core.hc

    Res:  2.05 Content
          &lt;/hc/&gt;;anchor="https://p.example.com";rt="core.hc"
                    
                  </pre>
<pre>
                    
    Req:  GET coap://[ff02::1]/.well-known/core?rt=core.hc

    Res:  2.05 Content
          &lt;/hc/&gt;;anchor="https://p.example.com";
          rt="core.hc";hct="?uri={+tu}"
                    
                  </pre>
<pre>
                    
    Req:  GET /.well-known/core?rt=core.hc HTTP/1.1
          Host: p.example.com

    Res:  HTTP/1.1 200 OK
          Content-Type: application/link-format
          Content-Length: 18

          &lt;/hc/&gt;;rt="core.hc"
                    
                    </pre>
<pre>
                      
    Req:  GET /.well-known/core?rt=core.hc HTTP/1.1
          Host: p.example.com

    Res:  HTTP/1.1 200 OK
          Content-Type: application/link-format+json
          Content-Length: 31

          [{"href":"/hc/","rt":"core.hc"}]
                    
                  </pre>
<pre>
                    
    Req:  GET /.well-known/core?rt=core.hc HTTP/1.1
          Host: p.example.com

    Res:  HTTP/1.1 200 OK
          Link: &lt;/hc/&gt;;rt="core.hc"
                    
                  </pre>
<p/>

<ul>
  <li>The first example exercises the CoAP interface and assumes that the default template, {+tu}, is used.  For example, a smartphone may discover the public HC Proxy before leaving the home network.  Then when outside the home network, the smartphone will be able to query the appropriate home sensor.  </li>
  <li>The second example - also on the CoAP side of the HC Proxy - uses a custom template, i.e., one where the CoAP URI is carried inside the query component, thus the returned link carries the URI template to be used in an explicit "hct" attribute: </li>
</ul>

<p> On the HTTP side, link information can be serialized in more than one way: </p>

<ul>
  <li>using the 'application/link-format' content type: </li>
  <li>using the 'application/link-format+json' content type as defined in <a href="#I-D.ietf-core-links-json">[I-D.ietf-core-links-json]</a>: </li>
  <li>using the Link header: </li>
</ul>

<p> </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#hc-media" id="hc-media">Media Type Mapping</a></h1>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> Overview</h1>
<p id="rfc.section.6.1.p.1">An HC Proxy needs to translate HTTP media types (Section 3.1.1.1 of <a href="#RFC7231">[RFC7231]</a>) and content encodings (Section 3.1.2.2 of <a href="#RFC7231">[RFC7231]</a>) into CoAP content formats (Section 12.3 of <a href="#RFC7252">[RFC7252]</a>) and vice versa.</p>
<p id="rfc.section.6.1.p.2">Media type translation can happen in GET, PUT or POST requests going from HTTP to CoAP, and in 2.xx (i.e., successful) responses going from CoAP to HTTP.  Specifically, PUT and POST need to map both the Content-Type and Content-Encoding HTTP headers into a single CoAP Content-Format option, whereas GET needs to map Accept and Accept-Encoding HTTP headers into a single CoAP Accept option.  To generate the HTTP response, the CoAP Content-Format option is mapped back to a suitable HTTP Content-Type and Content-Encoding combination.</p>
<p id="rfc.section.6.1.p.3">An HTTP request carrying a Content-Type and Content-Encoding combination which the HC Proxy is unable to map to an equivalent CoAP Content-Format, SHALL elicit a 415 (Unsupported Media Type) response by the HC Proxy.</p>
<p id="rfc.section.6.1.p.4">On the content negotiation side, failure to map Accept and Accept-* headers SHOULD be silently ignored: the HC Proxy SHOULD therefore forward as a CoAP request with no Accept option.  The HC Proxy thus disregards the Accept/Accept-* header fields by treating the response as if it is not subject to content negotiation, as mentioned in Sections 5.3.* of <a href="#RFC7231">[RFC7231]</a>.  However, an HC Proxy implementation is free to attempt mapping a single Accept header in a GET request to multiple CoAP GET requests, each with a single Accept option, which are then tried in sequence until one succeeds.  Note that an HTTP Accept */* MUST be mapped to a CoAP request without Accept option.</p>
<p id="rfc.section.6.1.p.5">While the CoAP to HTTP direction has always a well-defined mapping (with the exception examined in <a href="#sec-application-coap-payload">Section 6.2</a>), the HTTP to CoAP direction is more problematic because the source set, i.e., potentially 1000+ IANA registered media types, is much bigger than the destination set, i.e., the mere 6 values initially defined in Section 12.3 of <a href="#RFC7252">[RFC7252]</a>.</p>
<p id="rfc.section.6.1.p.6">Depending on the tight/loose coupling with the application(s) for which it proxies, the HC Proxy could implement different media type mappings.</p>
<p id="rfc.section.6.1.p.7">When tightly coupled, the HC Proxy knows exactly which content formats are supported by the applications, and can be strict when enforcing its forwarding policies in general, and the media type mapping in particular.</p>
<p id="rfc.section.6.1.p.8">On the other hand, when the HC Proxy is a general purpose ALG, being too strict could significantly reduce the amount of traffic that it would be able to successfully forward.  In this case, the "loose" media type mapping detailed in <a href="#sec-loose-mt-mapping">Section 6.3</a> MAY be implemented.</p>
<p id="rfc.section.6.1.p.9">The latter grants more evolution of the surrounding ecosystem, at the cost of allowing more attack surface.  In fact, as a result of such strategy, payloads would be forwarded more liberally across the unconstrained/constrained network boundary of the communication path.</p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#sec-application-coap-payload" id="sec-application-coap-payload">'application/coap-payload' Media Type</a></h1>
<p id="rfc.section.6.2.p.1">If the HC Proxy receives a CoAP response with a Content-Format that it does not recognize (e.g., because the value has been registered after the proxy has been deployed, or the CoAP server uses an experimental value which is not registered), then the HC Proxy SHALL return a generic "application/coap-payload" media type with numeric parameter "cf" as defined in <a href="#sec-coap-payload-reg">Section 9.2</a>.</p>
<p id="rfc.section.6.2.p.2">For example, the CoAP content format '60' ("application/cbor") would be represented by "application/coap-payload;cf=60", if the HC Proxy doesn't recognize the content format '60'.</p>
<p id="rfc.section.6.2.p.3">A HTTP client may use the media type "application/coap-payload" as a means to send a specific content format to a CoAP server via an HC Proxy if the client has determined that the HC Proxy does not directly support the type mapping it needs.  This case may happen when dealing for example with newly registered, yet to be registered, or experimental CoAP content formats.  However, unless explicitly configured to allow pass-through of unknown content formats, the HC Proxy SHOULD NOT forward requests carrying a Content-Type or Accept header with an "application/coap-payload", and return an appropriate client error instead.</p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#sec-loose-mt-mapping" id="sec-loose-mt-mapping">Loose Media Type Mapping</a></h1>
<p id="rfc.section.6.3.p.1">By structuring the type information in a super-class (e.g., "text") followed by a finer grained sub-class (e.g., "html"), and optional parameters (e.g., "charset=utf-8"), Internet media types provide a rich and scalable framework for encoding the type of any given entity.</p>
<p id="rfc.section.6.3.p.2">This approach is not applicable to CoAP, where Content Formats conflate an Internet media type (potentially with specific parameters) and a content encoding into one small integer value.</p>
<p id="rfc.section.6.3.p.3">To remedy this loss of flexibility, we introduce the concept of a "loose" media type mapping, where media types that are specializations of a more generic media type can be aliased to their super-class and then mapped (if possible) to one of the CoAP content formats.  For example, "application/soap+xml" can be aliased to "application/xml", which has a known conversion to CoAP.  In the context of this "loose" media type mapping, "application/octet-stream" can be used as a fallback when no better alias is found for a specific media type.</p>
<p><a href="#tab-generalised-mt">Table 1</a> defines the default lookup table for the "loose" media type mapping.  It is expected that an implementation can refine it either given application-specific knowledge, or because new Content-Formats are defined.  Given an input media type, the table returns its best generalized media type using the most specific match i.e., the table entries are compared to the input in top to bottom order until an entry matches.</p>
<div id="rfc.table.1"/>
<div id="tab-generalised-mt"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>Media type generalization lookup table</caption>
  <thead>
    <tr>
      <th class="left">Internet media type pattern</th>
      <th class="left">Generalized media type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">application/*+xml</td>
      <td class="left">application/xml</td>
    </tr>
    <tr>
      <td class="left">application/*+json</td>
      <td class="left">application/json</td>
    </tr>
    <tr>
      <td class="left">application/*+cbor</td>
      <td class="left">application/cbor</td>
    </tr>
    <tr>
      <td class="left">text/xml</td>
      <td class="left">application/xml</td>
    </tr>
    <tr>
      <td class="left">text/*</td>
      <td class="left">text/plain</td>
    </tr>
    <tr>
      <td class="left">*/*</td>
      <td class="left">application/octet-stream</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.3.p.5">The "loose" media type mapping is an OPTIONAL feature.  Implementations supporting this kind of mapping should provide a flexible way to define the set of media type generalizations allowed.</p>
<h1 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> <a href="#sec-mt2cf" id="sec-mt2cf">Media Type to Content Format Mapping Algorithm</a></h1>
<p id="rfc.section.6.4.p.1">This section defines the algorithm used to map an HTTP Internet media type to its correspondent CoAP content format; it can be used as a building block for translating HTTP Content-Type and Accept headers into CoAP Content-Format and Accept Options.</p>
<p id="rfc.section.6.4.p.2">The algorithm uses an IANA-maintained table, "CoAP Content-Formats", as established by Section 12.3 of <a href="#RFC7252">[RFC7252]</a> plus, possibly, any locally defined extension of it.  Optionally, the table and lookup mechanism described in <a href="#sec-loose-mt-mapping">Section 6.3</a> can be used if the implementation chooses so.</p>
<p id="rfc.section.6.4.p.3">Note that the algorithm assumes an "identity" Content-Encoding and expects the resource body has been already successfully content-decoded or transcoded to the desired format.</p>
<p id="rfc.section.6.4.p.4">In the following (<a href="#fig-mt2cf">Figure 2</a>): <a href="#appendix-mt2cf-impl">Appendix A</a>.  </p>

<ul>
  <li>media_type is the media type to translate;</li>
  <li>coap_cf_registry is a lookup table matching the CoAP Content Format Registry;</li>
  <li>loose_mapper is an optional lookup table describing the loose media type mappings (e.g., the one defined in <a href="#tab-generalised-mt">Table 1</a>);</li>
</ul>

<p> The full source code is provided in </p>
<div id="rfc.figure.2"/>
<div id="fig-mt2cf"/>
<pre>
            
def mt2cf(media_type, encoding=None,
          coap_cf_registry=CoAPContentFormatRegistry(),
          loose_mapper=None):
    """Return a CoAP Content-Format given an Internet Media Type and
       its optional encoding.  The current (as of 2016/10/24) CoAP
       Content Format Registry is supplied by default.  An optional
       'loose-mapping' implementation can be supplied by the caller."""
    assert media_type is not None
    assert coap_cf_registry is not None

    # Lookup the CoAP Content-Formats registry
    content_format = coap_cf_registry.lookup(media_type, encoding)

    # If an exact match is not found and a loose mapper has been
    # supplied, try to use it to get a media type with which to
    # re-try the CoAP Content-Formats registry lookup.
    if content_format is None and loose_mapper is not None:
        content_format = coap_cf_registry.lookup(
            loose_mapper.lookup(media_type), encoding)

    return content_format
            
          </pre>
<p class="figure">Figure 2</p>
<h1 id="rfc.section.6.5"><a href="#rfc.section.6.5">6.5.</a> <a href="#sec-content-trans" id="sec-content-trans">Content Transcoding</a></h1>
<h1 id="rfc.section.6.5.1"><a href="#rfc.section.6.5.1">6.5.1.</a> General</h1>
<p id="rfc.section.6.5.1.p.1">Payload content transcoding is an OPTIONAL feature.  Implementations supporting this feature should provide a flexible way to define the set of transcodings allowed.</p>
<p id="rfc.section.6.5.1.p.2">The HC Proxy might decide to transcode the received representation to a different (compatible) format when an optimized version of a specific format exists.  For example, a XML-encoded resource could be transcoded to Efficient XML Interchange (EXI) format, or a JSON-encoded resource into CBOR <a href="#RFC7049">[RFC7049]</a>, effectively achieving compression without losing any information.</p>
<p id="rfc.section.6.5.1.p.3">However, there are a few important factors to keep in mind when enabling a transcoding function: </p>

<ol>
  <li>Maliciously crafted inputs coming from the HTTP side might inflate in size (see for example Section 4.2 of <a href="#RFC7049">[RFC7049]</a>), therefore creating a security threat for both the HC Proxy and the target resource;</li>
  <li>Transcoding can lose information in non-obvious ways.  For example, encoding a XML document using schema-informed EXI encoding leads to a loss of information when the destination does not know the exact schema version used by the encoder.  That means that whenever the HC Proxy transcodes an application/XML to application/EXI in-band metadata could be lost.</li>
  <li>When content-type is mapped, there is a risk that the content with the destination type would have malware not active in the source type.</li>
</ol>

<p> It is crucial that these risks are well understood and carefully weighed against the actual benefits before deploying the transcoding function.  </p>
<h1 id="rfc.section.6.5.2"><a href="#rfc.section.6.5.2">6.5.2.</a> CoRE Link Format</h1>
<p id="rfc.section.6.5.2.p.1">The CoRE Link Format <a href="#RFC6690">[RFC6690]</a> is a set of links (i.e., URIs and their formal relationships) which is carried as content payload in a CoAP response.  These links usually include CoAP URIs that might be translated by the HC Proxy to the correspondent HTTP URIs using the implemented URI mapping function (see <a href="#URI-mapping">Section 5</a>).  Such a process would inspect the forwarded traffic and attempt to re-write the body of resources with an application/link-format media type, mapping the embedded CoAP URIs to their HTTP counterparts.  Some potential issues with this approach are: </p>

<ol>
  <li>The client may be interested in retrieving original (unaltered) CoAP payloads through the HC Proxy, not modified versions.</li>
  <li>Tampering with payloads is incompatible with resources that are integrity protected (although this is a problem with transcoding in general).</li>
  <li>The HC Proxy needs to fully understand <a href="#RFC6690">[RFC6690]</a> syntax and semantics, otherwise there is an inherent risk to corrupt the payloads.</li>
</ol>

<p> Therefore, CoRE Link Format payload should only be transcoded at the risk and discretion of the proxy implementer.</p>
<h1 id="rfc.section.6.5.3"><a href="#rfc.section.6.5.3">6.5.3.</a> <a href="#sec-diagnostic" id="sec-diagnostic">Diagnostic Messages</a></h1>
<p id="rfc.section.6.5.3.p.1">CoAP responses may, in certain error cases, contain a diagnostic message in the payload explaining the error situation, as described in Section 5.5.2 of <a href="#RFC7252">[RFC7252]</a>.  If present, the CoAP response diagnostic payload SHOULD be copied in the HTTP response body.  The CoAP diagnostic message MUST NOT be copied into the HTTP reason-phrase, since it potentially contains CR-LF characters which are incompatible with HTTP reason-phrase syntax.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#hc-resp" id="hc-resp">Response Code Mapping</a></h1>
<p><a href="#tab-http-coap">Table 2</a> defines the HTTP response status codes to which each CoAP response code SHOULD be mapped.  Multiple appearances of a HTTP status code in the second column indicates multiple equivalent HTTP responses are possible based on the same CoAP response code, depending on the conditions cited in the Notes (third column and text below table).</p>
<div id="rfc.table.2"/>
<div id="tab-http-coap"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>CoAP-HTTP Response Code Mappings</caption>
  <thead>
    <tr>
      <th class="left">CoAP Response Code</th>
      <th class="left">HTTP Status Code</th>
      <th class="left">Note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">2.01 Created      </td>
      <td class="left">201 Created     </td>
      <td class="left">1</td>
    </tr>
    <tr>
      <td class="left">2.02 Deleted      </td>
      <td class="left">200 OK</td>
      <td class="left">2</td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">204 No Content</td>
      <td class="left">2</td>
    </tr>
    <tr>
      <td class="left">2.03 Valid</td>
      <td class="left">304 Not Modified</td>
      <td class="left">3</td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">200 OK</td>
      <td class="left">4</td>
    </tr>
    <tr>
      <td class="left">2.04 Changed       </td>
      <td class="left">200 OK           </td>
      <td class="left">2</td>
    </tr>
    <tr>
      <td class="left"/>
      <td class="left">204 No Content   </td>
      <td class="left">2</td>
    </tr>
    <tr>
      <td class="left">2.05 Content       </td>
      <td class="left">200 OK           </td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">2.31 Continue      </td>
      <td class="left">N/A</td>
      <td class="left">10</td>
    </tr>
    <tr>
      <td class="left">4.00 Bad Request   </td>
      <td class="left">400 Bad Request  </td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">4.01 Unauthorized  </td>
      <td class="left">403 Forbidden    </td>
      <td class="left">5</td>
    </tr>
    <tr>
      <td class="left">4.02 Bad Option    </td>
      <td class="left">400 Bad Request  </td>
      <td class="left">6</td>
    </tr>
    <tr>
      <td class="left">4.02 Bad Option    </td>
      <td class="left">500 Internal Server Error</td>
      <td class="left">6</td>
    </tr>
    <tr>
      <td class="left">4.03 Forbidden    </td>
      <td class="left">403 Forbidden   </td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">4.04 Not Found    </td>
      <td class="left">404 Not Found   </td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">4.05 Method Not Allowed</td>
      <td class="left">400 Bad Request     </td>
      <td class="left">7</td>
    </tr>
    <tr>
      <td class="left">4.06 Not Acceptable </td>
      <td class="left">406 Not Acceptable  </td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">4.08 Request Entity Incomplt.</td>
      <td class="left">N/A</td>
      <td class="left">10</td>
    </tr>
    <tr>
      <td class="left">4.12 Precondition Failed </td>
      <td class="left">412 Precondition Failed </td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">4.13 Request Ent. Too Large</td>
      <td class="left">413 Payload Too Large</td>
      <td class="left">11</td>
    </tr>
    <tr>
      <td class="left">4.15 Unsupported Content-Fmt.</td>
      <td class="left">415 Unsupported Media Type</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">5.00 Internal Server Error</td>
      <td class="left">500 Internal Server Error</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">5.01 Not Implemented    </td>
      <td class="left">501 Not Implemented   </td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">5.02 Bad Gateway        </td>
      <td class="left">502 Bad Gateway       </td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">5.03 Service Unavailable </td>
      <td class="left">503 Service Unavailable  </td>
      <td class="left">8</td>
    </tr>
    <tr>
      <td class="left">5.04 Gateway Timeout     </td>
      <td class="left">504 Gateway Timeout      </td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">5.05 Proxying Not Supported  </td>
      <td class="left">502 Bad Gateway         </td>
      <td class="left">9</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.7.p.2">Notes: </p>

<ol>
  <li>A CoAP server may return an arbitrary format payload along with this response. If present, this payload MUST be returned as entity in the HTTP 201 response. Section 7.3.2 of <a href="#RFC7231">[RFC7231]</a> does not put any requirement on the format of the entity. (In the past, <a href="#RFC2616">[RFC2616]</a> did.)</li>
  <li>The HTTP code is 200 or 204 respectively for the case that a CoAP server returns a payload or not. <a href="#RFC7231">[RFC7231]</a> Section 5.3 requires code 200 in case a representation of the action result is returned for DELETE/POST/PUT, and code 204 if not. Hence, a proxy MUST transfer any CoAP payload contained in a CoAP 2.02 response to the HTTP client using a 200 OK response.</li>
  <li>HTTP code 304 (Not Modified) is sent if the HTTP client performed a conditional HTTP request and the CoAP server responded with 2.03 (Valid) to the corresponding CoAP validation request. Note that Section 4.1 of <a href="#RFC7232">[RFC7232]</a> puts some requirements on header fields that must be present in the HTTP 304 response.</li>
  <li>A 200 response to a CoAP 2.03 occurs only when the HC Proxy, for efficiency reasons, is running a local cache.  An unconditional HTTP GET which produces a cache-hit, could trigger a re-validation (i.e., a conditional GET) on the CoAP side.  The proxy receiving 2.03 updates the freshness of its cached representation and returns it to the HTTP client.</li>
  <li>A HTTP 401 Unauthorized (Section 3.1 of <a href="#RFC7235">[RFC7235]</a>) response is not applicable because there is no equivalent in CoAP of WWW-Authenticate which is mandatory in a HTTP 401 response.</li>
  <li>If the proxy has a way to determine that the Bad Option is due to the straightforward mapping of a client request header into a CoAP option, then returning HTTP 400 (Bad Request) is appropriate.  In all other cases, the proxy MUST return HTTP 500 (Internal Server Error) stating its inability to provide a suitable translation to the client's request.</li>
  <li>A CoAP 4.05 (Method Not Allowed) response SHOULD normally be mapped to a HTTP 400 (Bad Request) code, because the HTTP 405 response would require specifying the supported methods - which are generally unknown.  In this case the HC Proxy SHOULD also return a HTTP reason-phrase in the HTTP status line that starts with the string "CoAP server returned 4.05" in order to facilitate troubleshooting.  However, if the HC Proxy has more granular information about the supported methods for the requested resource (e.g., via a Resource Directory (<a href="#I-D.ietf-core-resource-directory">[I-D.ietf-core-resource-directory]</a>)) then it MAY send back a HTTP 405 (Method Not Allowed) with a properly filled in "Allow" response-header field (Section 7.4.1 of <a href="#RFC7231">[RFC7231]</a>).</li>
  <li>The value of the HTTP "Retry-After" response-header field is taken from the value of the CoAP Max-Age Option, if present.</li>
  <li>This CoAP response can only happen if the proxy itself is configured to use a CoAP forward-proxy (Section 5.7 of <a href="#RFC7252">[RFC7252]</a>) to execute some, or all, of its CoAP requests.</li>
  <li>Only used in CoAP blockwise transfer <a href="#RFC7959">[RFC7959]</a> between HC Proxy and CoAP server; never translated into a HTTP response.</li>
  <li>Only returned to the HTTP client if the HC Proxy was unable to successfully complete the request by retrying it with CoAP blockwise transfer; see <a href="#hc-block">Section 8.3</a>.</li>
</ol>

<p> </p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#hc-additional" id="hc-additional">Additional Mapping Guidelines</a></h1>
<h1 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> <a href="#hc-caching" id="hc-caching">Caching and Congestion Control</a></h1>
<p id="rfc.section.8.1.p.1">An HC Proxy should cache CoAP responses, and reply whenever applicable with a cached representation of the requested resource.</p>
<p id="rfc.section.8.1.p.2">If the HTTP client drops the connection after the HTTP request was made, an HC Proxy should wait for the associated CoAP response and cache it if possible.  Subsequent requests to the HC Proxy for the same resource can use the result present in cache, or, if a response has still to come, the HTTP requests will wait on the open CoAP request.</p>
<p id="rfc.section.8.1.p.3">According to <a href="#RFC7252">[RFC7252]</a>, a proxy must limit the number of outstanding requests to a given CoAP server to NSTART. To limit the amount of aggregate traffic to a constrained network, the HC Proxy should also put a limit on the number of concurrent CoAP requests pending on the same constrained network; further incoming requests may either be queued or dropped (returning 503 Service Unavailable). This limit and the proxy queueing/dropping behavior should be configurable.</p>
<p id="rfc.section.8.1.p.4">Highly volatile resources that are being frequently requested may be observed <a href="#RFC7641">[RFC7641]</a> by the HC Proxy to keep their cached representation fresh while minimizing the amount of CoAP traffic in the constrained network (see <a href="#refresh_via_observe">Section 8.2</a>).</p>
<h1 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> <a href="#refresh_via_observe" id="refresh_via_observe">Cache Refresh via Observe</a></h1>
<p id="rfc.section.8.2.p.1">There are cases where using the CoAP observe protocol <a href="#RFC7641">[RFC7641]</a> to handle proxy cache refresh is preferable to the validation mechanism based on ETag as defined in <a href="#RFC7252">[RFC7252]</a>.  Such scenarios include sleepy CoAP nodes - with possibly high variance in requests' distribution - which would greatly benefit from a server-driven cache update mechanism.  Ideal candidates for CoAP observe are also crowded or very low throughput networks, where reduction of the total number of exchanged messages is an important requirement.</p>
<p id="rfc.section.8.2.p.2">This subsection aims at providing a practical evaluation method to decide whether refreshing a cached resource R is more efficiently handled via ETag validation or by establishing an observation on R.  The idea being that the HC Proxy proactively installs an observation on a "popular enough" resource and actively monitors: </p>

<ol style="list-style-type: lower-alpha">
  <li>Its update pattern on the CoAP side; and</li>
  <li>The request pattern on the HTTP side;</li>
</ol>

<p> and uses the formula below to determine whether the observation should be kept alive or shut down.  </p>
<p id="rfc.section.8.2.p.3">Let T_R be the mean time between two client requests to resource R, let T_C be the mean time between two representation changes of R, and let M_R be the mean number of CoAP messages per second exchanged to and from resource R.  If we assume that the initial cost for establishing the observation is negligible, an observation on R reduces M_R if and only if T_R &lt; 2*T_C with respect to using ETag validation, that is if and only if the mean arrival rate of requests for resource R is greater than half the change rate of R.</p>
<p id="rfc.section.8.2.p.4">When observing the resource R, M_R is always upper bounded by 2/T_C.</p>
<h1 id="rfc.section.8.3"><a href="#rfc.section.8.3">8.3.</a> <a href="#hc-block" id="hc-block">Use of CoAP Blockwise Transfer</a></h1>
<p id="rfc.section.8.3.p.1">An HC Proxy SHOULD support CoAP blockwise transfers <a href="#RFC7959">[RFC7959]</a> to allow transport of large CoAP payloads while avoiding excessive link-layer fragmentation in constrained networks, and to cope with small datagram buffers in CoAP endpoints as described in <a href="#RFC7252">[RFC7252]</a> Section 4.6.</p>
<p id="rfc.section.8.3.p.2">An HC Proxy SHOULD attempt to retry a payload-carrying CoAP PUT or POST request with blockwise transfer if the destination CoAP server responded with 4.13 (Request Entity Too Large) to the original request.  An HC Proxy SHOULD attempt to use blockwise transfer when sending a CoAP PUT or POST request message that is larger than BLOCKWISE_THRESHOLD bytes. The value of BLOCKWISE_THRESHOLD is implementation-specific; for example, it can be: </p>

<ul>
  <li>Calculated based on a known or typical UDP datagram buffer size for CoAP endpoints, or</li>
  <li>Set to N times the known size of a link-layer frame in a constrained network where e.g., N=5, or</li>
  <li>Preset to a known IP MTU value, or</li>
  <li>Set to a known Path MTU value.</li>
</ul>

<p> The value BLOCKWISE_THRESHOLD, or the parameters from which it is calculated, should be configurable in a proxy implementation. The maximum block size the proxy will attempt to use in CoAP requests should also be configurable.</p>
<p id="rfc.section.8.3.p.3">The HC Proxy SHOULD detect CoAP endpoints not supporting blockwise transfers.  This can be done by checking for a 4.02 (Bad Option) response returned by an endpoint in response to a CoAP request with a Block* Option, and subsequent absence of the 4.02 in response to the same request without Block* Options.  This allows the HC Proxy to be more efficient, not attempting repeated blockwise transfers to CoAP servers that do not support it.</p>
<h1 id="rfc.section.8.4"><a href="#rfc.section.8.4">8.4.</a> <a href="#hc-multicast" id="hc-multicast">CoAP Multicast</a></h1>
<p id="rfc.section.8.4.p.1">An HC Proxy MAY support CoAP multicast. If it does, the HC Proxy sends out a multicast CoAP request if the Target CoAP URI's authority is a multicast IP literal or resolves to a multicast IP address.  If the HC Proxy does not support CoAP multicast, it SHOULD respond 403 (Forbidden) to any valid HTTP request that maps to a CoAP multicast request.</p>
<p id="rfc.section.8.4.p.2">Details related to supporting CoAP multicast are currently out of scope of this document since in a proxy scenario an HTTP client typically expects to receive a single response, not multiple.  However, an HC Proxy that implements CoAP multicast may include application-specific functions to aggregate multiple CoAP responses into a single HTTP response.  We suggest using the "application/http" internet media type (Section 8.3.2 of <a href="#RFC7230">[RFC7230]</a>) to enclose a set of one or more HTTP response messages, each representing the mapping of one CoAP response.</p>
<p id="rfc.section.8.4.p.3">For further considerations related to the handling of multicast requests, see <a href="#sec.multicast">Section 10.1</a>.</p>
<h1 id="rfc.section.8.5"><a href="#rfc.section.8.5">8.5.</a> <a href="#hc-timeouts" id="hc-timeouts">Timeouts</a></h1>
<p id="rfc.section.8.5.p.1">If the CoAP server takes a long time in responding, the HTTP client or any other proxy in between may timeout.  Further discussion of timeouts in HTTP is available in Section 6.2.4 of <a href="#RFC7230">[RFC7230]</a>.</p>
<p id="rfc.section.8.5.p.2">An HC Proxy MUST define an internal timeout for each pending CoAP request, because the CoAP server may silently die before completing the request.  Assuming the Proxy uses confirmable CoAP requests, such timeout value T SHOULD be at least</p>
<p id="rfc.section.8.5.p.3">T = MAX_RTT + MAX_SERVER_RESPONSE_DELAY</p>
<p id="rfc.section.8.5.p.4">where MAX_RTT is defined in <a href="#RFC7252">[RFC7252]</a> and MAX_SERVER_RESPONSE_DELAY is defined in <a href="#RFC7390">[RFC7390]</a>.</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#IANA" id="IANA">IANA Considerations</a></h1>
<h1 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a> <a href="#sec-core-hc-reg" id="sec-core-hc-reg">New 'core.hc' Resource Type</a></h1>
<p id="rfc.section.9.1.p.1">This document registers a new Resource Type (rt=) Link Target Attribute, 'core.hc', in the "Resource Type (rt=) Link Target Attribute Values" subregistry under the "Constrained RESTful Environments (CoRE) Parameters" registry.</p>
<p id="rfc.section.9.1.p.2">Attribute Value: core.hc</p>
<p id="rfc.section.9.1.p.3">Description: HTTP to CoAP mapping base resource.</p>
<p id="rfc.section.9.1.p.4">Reference: See <a href="#section.discovery">Section 5.5</a>.</p>
<h1 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a> <a href="#sec-coap-payload-reg" id="sec-coap-payload-reg">New 'coap-payload' Internet Media Type</a></h1>
<p id="rfc.section.9.2.p.1">This document defines the "application/coap-payload" media type with a single parameter "cf". This media type represents any payload that a CoAP message can carry, having a content format that can be identified by an integer in range 0-65535 corresponding to a CoAP Content-Format parameter (<a href="#RFC7252">[RFC7252]</a>, Section 12.3).  The parameter "cf" is the integer defining the CoAP content format.</p>
<p id="rfc.section.9.2.p.2">Type name: application</p>
<p id="rfc.section.9.2.p.3">Subtype name: coap-payload</p>
<p id="rfc.section.9.2.p.4">Required parameters: cf (CoAP Content-Format integer in range 0-65535 denoting the content format of the CoAP payload carried, as defined by the "CoAP Content-Formats" subregistry that is part of the "Constrained RESTful Environments (CoRE) Parameters" registry.)</p>
<p id="rfc.section.9.2.p.5">Optional parameters: None</p>
<p id="rfc.section.9.2.p.6">Encoding considerations: Common use is BINARY.  The specific CoAP content format encoding considerations for the selected Content-Format (cf parameter) apply.  The encoding can vary based on the value of the cf parameter.</p>
<p id="rfc.section.9.2.p.7">Security considerations: The specific CoAP content format security considerations for the selected Content-Format (cf parameter) apply.</p>
<p id="rfc.section.9.2.p.8">Interoperability considerations: This media type can never be used directly in CoAP messages because there are no means available to encode the mandatory 'cf' parameter in CoAP.</p>
<p id="rfc.section.9.2.p.9">Published specification: (this I-D - TBD)</p>
<p id="rfc.section.9.2.p.10">Applications that use this media type: HTTP-to-CoAP Proxies.</p>
<p id="rfc.section.9.2.p.11">Fragment identifier considerations: CoAP does not support URI fragments; therefore a CoAP payload fragment cannot be identified. Fragments are not applicable for this media type.</p>
<p id="rfc.section.9.2.p.12">Additional information: </p>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">Deprecated alias names for this type: N/A</dd>
  <dt></dt>
  <dd style="margin-left: 8">Magic number(s): N/A</dd>
  <dt></dt>
  <dd style="margin-left: 8">File extension(s): N/A</dd>
  <dt></dt>
  <dd style="margin-left: 8">Macintosh file type code(s): N/A</dd>
</dl>

<p> </p>
<p id="rfc.section.9.2.p.13">Person and email address to contact for further information: </p>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">Esko Dijk ("esko@ieee.org")</dd>
</dl>

<p> </p>
<p id="rfc.section.9.2.p.14">Intended usage: COMMON</p>
<p id="rfc.section.9.2.p.15">Restrictions on usage:</p>
<p id="rfc.section.9.2.p.16">An application (or user) can only use this media type if it has to represent a CoAP payload of which the specified CoAP Content-Format is an unrecognized number; such that a proper translation directly to the equivalent HTTP media type is not possible.</p>
<p id="rfc.section.9.2.p.17">Author: CoRE WG</p>
<p id="rfc.section.9.2.p.18">Change controller: IETF</p>
<p id="rfc.section.9.2.p.19">Provisional registration: No</p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#sec" id="sec">Security Considerations</a></h1>
<p id="rfc.section.10.p.1">The security considerations in Section 9.2 of <a href="#RFC7230">[RFC7230]</a> apply in full to the HC Proxy.  This section discusses security aspects and requirements that are specific to the deployment and operation of an HC Proxy.</p>
<p id="rfc.section.10.p.2">An HC Proxy located at the boundary of a constrained network is an easy single point of failure for reducing availability.  As such, special care should be taken in designing, developing and operating it, keeping in mind that, in most cases, it has fewer limitations than the constrained devices it is serving.  In particular, its quality of implementation and operation - i.e., use of current software development practices, careful selection of third party libraries, sane configuration defaults, an expedited way to upgrade a running instance - are all essential attributes of the HC Proxy.</p>
<p id="rfc.section.10.p.3">The correctness of request parsing in general (including any content transcoding), and of URI translation in particular, is essential to the security of the HC Proxy function.  This is especially true when the internal network hosts devices with genuinely limited capabilities.  For this purpose, see also Sections 9.3, 9.4, 9.5 and 9.6 of <a href="#RFC7230">[RFC7230]</a> for well-known issues related to HTTP request parsing and Section 11.1 of <a href="#RFC7252">[RFC7252]</a> for an overview of CoAP specific concerns related to URI processing - in particular, the potential impact on access control mechanisms that are based on URIs.</p>
<p id="rfc.section.10.p.4">An HC Proxy MUST implement TLS with PSK <a href="#RFC4279">[RFC4279]</a> and SHOULD implement TLS <a href="#RFC5246">[RFC5246]</a> with support for client authentication using X.509 certificates.  A prerequisite of the latter is the availability of a Certification Authority (CA) to issue suitable certificates.  Although this can be a challenging requirement in certain application scenarios, it is worth noting that there exist open-source tools (e.g., <a href="#OpenSSL">[OpenSSL]</a>) that can be used to set up and operate an application-specific CA.</p>
<p id="rfc.section.10.p.5">By default, the HC Proxy MUST authenticate all incoming requests prior to forwarding them to the CoAP server.  This default behavior MAY be explicitly disabled by an administrator.</p>
<p id="rfc.section.10.p.6">The following subparagraphs categorize and discuss a set of specific security issues related to the translation, caching and forwarding functionality exposed by an HC Proxy.</p>
<h1 id="rfc.section.10.1"><a href="#rfc.section.10.1">10.1.</a> <a href="#sec.multicast" id="sec.multicast">Multicast</a></h1>
<p id="rfc.section.10.1.p.1">Multicast requests impose a non-trivial cost on the constrained network and endpoints and might be exploited as a DoS attack vector (see also <a href="#sec.traffic-overflow">Section 10.2</a>).  From a privacy perspective, they can be used to gather detailed information about the resources hosted in the constrained network.  For example, an outsider that is able to successfully query the /.well-known/core could obtain a comprehensive list of the target's home appliances and devices.  From a security perspective, they can be used to carry out a network reconnaissance attack to gather information about possible vulnerabilities that could be exploited at a later point in time.  For these reasons, it is RECOMMENDED that requests to multicast resources are access controlled with a default-deny policy.  It is RECOMMENDED that the requestor of a multicast resource be strongly authenticated.  If privacy and / or security are first class requirements, for example whenever the HTTP request transits through the public Internet, the request SHOULD be transported over a mutually authenticated and encrypted TLS connection.</p>
<h1 id="rfc.section.10.2"><a href="#rfc.section.10.2">10.2.</a> <a href="#sec.traffic-overflow" id="sec.traffic-overflow">Traffic Overflow</a></h1>
<p id="rfc.section.10.2.p.1">Due to the typically constrained nature of CoAP nodes, particular attention should be given to the implementation of traffic reduction mechanisms (see <a href="#hc-caching">Section 8.1</a>), because an inefficient proxy implementations can be targeted by unconstrained Internet attackers.  Bandwidth or complexity involved in such attacks is very low.</p>
<p id="rfc.section.10.2.p.2">An amplification attack to the constrained network may be triggered by a multicast request generated by a single HTTP request which is mapped to a CoAP multicast resource, as discussed in Section 11.3 of <a href="#RFC7252">[RFC7252]</a>.</p>
<p id="rfc.section.10.2.p.3">The risk likelihood of this amplification technique is higher than an amplification attack carried out by a malicious constrained device (e.g., ICMPv6 flooding, like Packet Too Big, or Parameter Problem on a multicast destination <a href="#RFC4732">[RFC4732]</a>) since it does not require direct access to the constrained network.</p>
<p id="rfc.section.10.2.p.4">The feasibility of this attack, which disrupts availability of the targeted CoAP server, can be limited by access controlling the exposed multicast resources, so that only known/authorized users can access such URIs.</p>
<h1 id="rfc.section.10.3"><a href="#rfc.section.10.3">10.3.</a> <a href="#sec-exchanges" id="sec-exchanges">Handling Secured Exchanges</a></h1>
<p id="rfc.section.10.3.p.1">An HTTP request can be sent to the HC Proxy over a secured connection.  However, there may not always exist a secure connection mapping to CoAP.  For example, a secure distribution method for multicast traffic is complex and may not be implemented (see <a href="#RFC7390">[RFC7390]</a>).</p>
<p id="rfc.section.10.3.p.2">An HC Proxy should implement rules for security context translations.  For example, all 'https' unicast requests are translated to 'coaps' requests, or 'https' requests are translated to unsecured 'coap' requests.  Another rule could specify the security policy and parameters used for DTLS sessions <a href="#RFC7925">[RFC7925]</a>. Such rules will largely depend on the application and network context in which the HC Proxy operates.  These rules should be configurable.</p>
<p id="rfc.section.10.3.p.3">It is RECOMMENDED that, by default, accessing a 'coaps' URI is only allowed from a corresponding 'https' URI.</p>
<p id="rfc.section.10.3.p.4">By default, an HC Proxy SHOULD reject any secured CoAP client request (i.e., one with a 'coaps' scheme) if there is no configured security policy mapping.  This recommendation may be relaxed in case the destination network is believed to be secured by other means.  Assuming that CoAP nodes are isolated behind a firewall as in the HC Proxy deployment shown in <a href="#fig-http-coap-deployment">Figure 1</a>, the HC Proxy may be configured to translate the incoming HTTPS request using plain CoAP (NoSec mode).</p>
<h1 id="rfc.section.10.4"><a href="#rfc.section.10.4">10.4.</a> URI Mapping</h1>
<p id="rfc.section.10.4.p.1">The following risks related to the URI mapping described in <a href="#URI-mapping">Section 5</a> and its use by HC Proxy have been identified: </p>

<dl>
  <dt>DoS attack on the constrained/CoAP network.</dt>
  <dd style="margin-left: 8"><br/>Mitigation: by default deny any Target CoAP URI whose authority is (or maps to) a multicast address.  Then explicitly white-list multicast resources/authorities that are allowed to be de-referenced. See also <a href="#hc-multicast">Section 8.4</a>.</dd>
  <dt>Leaking information on the constrained/CoAP network resources and topology.</dt>
  <dd style="margin-left: 8"><br/>Mitigation: by default deny any Target CoAP URI (especially /.well-known/core is a resource to be protected), and then explicitly white-list resources that are allowed to be seen from outside.</dd>
  <dt>The internal CoAP Target resource is totally transparent from outside.</dt>
  <dd style="margin-left: 8"><br/>Mitigation: implement an HTTPS-only interface, which makes the Target CoAP URI totally opaque to a passive attacker.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> Acknowledgments</h1>
<p id="rfc.section.11.p.1">An initial version of <a href="#tab-http-coap">Table 2</a> in <a href="#hc-resp">Section 7</a> has been provided in revision -05 of the CoRE CoAP I-D.  Special thanks to Peter van der Stok for countless comments and discussions on this document that contributed to its current structure and text.</p>
<p id="rfc.section.11.p.2">Thanks to Abhijan Bhattacharyya, Alexey Melnikov, Brian Frank, Carsten Bormann, Christian Amsuess, Christian Groves, Cullen Jennings, Dorothy Gellert, Francesco Corazza, Francis Dupont, Hannes Tschofenig, Jaime Jimenez, Kathleen Moriarty, Kepeng Li, Kerry Lynn, Klaus Hartke, Larry Masinter, Linyi Tian, Michele Rossi, Michele Zorzi, Nicola Bui, Peter Saint-Andre, Sean Leonard, Spencer Dawkins, Stephen Farrell, Suresh Krishnan, Zach Shelby for helpful comments and discussions that have shaped the document.</p>
<p id="rfc.section.11.p.3">The research leading to these results has received funding from the European Community's Seventh Framework Programme [FP7/2007-2013] under grant agreement n.251557.</p>
<h1 id="rfc.references"><a href="#rfc.references">12.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">12.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3986">[RFC3986]</b>
      </td>
      <td class="top"><a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4279">[RFC4279]</b>
      </td>
      <td class="top"><a>Eronen, P.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc4279">Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)</a>", RFC 4279, DOI 10.17487/RFC4279, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5234">[RFC5234]</b>
      </td>
      <td class="top"><a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6570">[RFC6570]</b>
      </td>
      <td class="top"><a>Gregorio, J.</a>, <a>Fielding, R.</a>, <a>Hadley, M.</a>, <a>Nottingham, M.</a> and <a>D. Orchard</a>, "<a href="http://tools.ietf.org/html/rfc6570">URI Template</a>", RFC 6570, DOI 10.17487/RFC6570, March 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6690">[RFC6690]</b>
      </td>
      <td class="top"><a>Shelby, Z.</a>, "<a href="http://tools.ietf.org/html/rfc6690">Constrained RESTful Environments (CoRE) Link Format</a>", RFC 6690, DOI 10.17487/RFC6690, August 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7231">[RFC7231]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7232">[RFC7232]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7232">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</a>", RFC 7232, DOI 10.17487/RFC7232, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7235">[RFC7235]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7235">Hypertext Transfer Protocol (HTTP/1.1): Authentication</a>", RFC 7235, DOI 10.17487/RFC7235, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7252">[RFC7252]</b>
      </td>
      <td class="top"><a>Shelby, Z.</a>, <a>Hartke, K.</a> and <a>C. Bormann</a>, "<a href="http://tools.ietf.org/html/rfc7252">The Constrained Application Protocol (CoAP)</a>", RFC 7252, DOI 10.17487/RFC7252, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7641">[RFC7641]</b>
      </td>
      <td class="top"><a>Hartke, K.</a>, "<a href="http://tools.ietf.org/html/rfc7641">Observing Resources in the Constrained Application Protocol (CoAP)</a>", RFC 7641, DOI 10.17487/RFC7641, September 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7959">[RFC7959]</b>
      </td>
      <td class="top"><a>Bormann, C.</a> and <a>Z. Shelby</a>, "<a href="http://tools.ietf.org/html/rfc7959">Block-Wise Transfers in the Constrained Application Protocol (CoAP)</a>", RFC 7959, DOI 10.17487/RFC7959, August 2016.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">12.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="Fielding">[Fielding]</b>
      </td>
      <td class="top"><a title="IEEE">Fielding, R.</a>, "<a>Architectural Styles and the Design of Network-based Software Architectures</a>", PhD Dissertation, University of California, Irvine, ISBN 0-599-87118-0, 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-core-links-json">[I-D.ietf-core-links-json]</b>
      </td>
      <td class="top"><a>Li, K.</a>, <a>Rahman, A.</a> and <a>C. Bormann</a>, "<a href="http://tools.ietf.org/html/draft-ietf-core-links-json-06">Representing CoRE Formats in JSON and CBOR</a>", Internet-Draft draft-ietf-core-links-json-06, July 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-core-resource-directory">[I-D.ietf-core-resource-directory]</b>
      </td>
      <td class="top"><a>Shelby, Z.</a>, <a>Koster, M.</a>, <a>Bormann, C.</a> and <a>P. Stok</a>, "<a href="http://tools.ietf.org/html/draft-ietf-core-resource-directory-09">CoRE Resource Directory</a>", Internet-Draft draft-ietf-core-resource-directory-09, October 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="OpenSSL">[OpenSSL]</b>
      </td>
      <td class="top"><a>The OpenSSL Project, </a>, "<a href="https://www.openssl.org/docs/manmaster/man1/ca.html">ca - sample minimal CA application</a>", 1998-2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2616">[RFC2616]</b>
      </td>
      <td class="top"><a>Fielding, R.</a>, <a>Gettys, J.</a>, <a>Mogul, J.</a>, <a>Frystyk, H.</a>, <a>Masinter, L.</a>, <a>Leach, P.</a> and <a>T. Berners-Lee</a>, "<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>", RFC 2616, DOI 10.17487/RFC2616, June 1999.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3040">[RFC3040]</b>
      </td>
      <td class="top"><a>Cooper, I.</a>, <a>Melve, I.</a> and <a>G. Tomlinson</a>, "<a href="http://tools.ietf.org/html/rfc3040">Internet Web Replication and Caching Taxonomy</a>", RFC 3040, DOI 10.17487/RFC3040, January 2001.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4732">[RFC4732]</b>
      </td>
      <td class="top"><a>Handley, M.</a>, <a>Rescorla, E.</a> and <a>IAB</a>, "<a href="http://tools.ietf.org/html/rfc4732">Internet Denial-of-Service Considerations</a>", RFC 4732, DOI 10.17487/RFC4732, December 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6454">[RFC6454]</b>
      </td>
      <td class="top"><a>Barth, A.</a>, "<a href="http://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>", RFC 6454, DOI 10.17487/RFC6454, December 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7049">[RFC7049]</b>
      </td>
      <td class="top"><a>Bormann, C.</a> and <a>P. Hoffman</a>, "<a href="http://tools.ietf.org/html/rfc7049">Concise Binary Object Representation (CBOR)</a>", RFC 7049, DOI 10.17487/RFC7049, October 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7228">[RFC7228]</b>
      </td>
      <td class="top"><a>Bormann, C.</a>, <a>Ersue, M.</a> and <a>A. Keranen</a>, "<a href="http://tools.ietf.org/html/rfc7228">Terminology for Constrained-Node Networks</a>", RFC 7228, DOI 10.17487/RFC7228, May 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7390">[RFC7390]</b>
      </td>
      <td class="top"><a>Rahman, A.</a> and <a>E. Dijk</a>, "<a href="http://tools.ietf.org/html/rfc7390">Group Communication for the Constrained Application Protocol (CoAP)</a>", RFC 7390, DOI 10.17487/RFC7390, October 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7925">[RFC7925]</b>
      </td>
      <td class="top"><a>Tschofenig, H.</a> and <a>T. Fossati</a>, "<a href="http://tools.ietf.org/html/rfc7925">Transport Layer Security (TLS) / Datagram Transport Layer Security (DTLS) Profiles for the Internet of Things</a>", RFC 7925, DOI 10.17487/RFC7925, July 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="W3C.REC-html5-20141028">[W3C.REC-html5-20141028]</b>
      </td>
      <td class="top"><a>Hickson, I.</a>, <a>Berjon, R.</a>, <a>Faulkner, S.</a>, <a>Leithead, T.</a>, <a>Navara, E.</a>, <a>O'Connor, E.</a> and <a>S. Pfeiffer</a>, "<a href="http://www.w3.org/TR/2014/REC-html5-20141028">HTML5</a>", W3C Recommendation REC-html5-20141028, 2014.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#appendix-mt2cf-impl" id="appendix-mt2cf-impl">Media Type Mapping Source Code</a></h1>
<pre>
            
#!/usr/bin/env python

import unittest
import re


class CoAPContentFormatRegistry(object):
    """Map an Internet media type (and optional inherent encoding) to a
       CoAP content format.
    """
    TEXT_PLAIN = 0
    LINK_FORMAT = 40
    XML = 41
    OCTET_STREAM = 42
    EXI = 47
    JSON = 50
    CBOR = 60
    GROUP_JSON = 256

# http://www.iana.org/assignments/core-parameters/core-parameters.xhtml
# as of 2016/10/24.
    LOOKUP_TABLE = {
        ("text/plain;charset=utf-8", None): TEXT_PLAIN,
        ("application/link-format", None): LINK_FORMAT,
        ("application/xml", None): XML,
        ("application/octet-stream", None): OCTET_STREAM,
        ("application/exi", None): EXI,
        ("application/json", None): JSON,
        ("application/cbor", None): CBOR,
        ("application/coap-group+json", "utf-8"): GROUP_JSON,
    }

    def lookup(self, media_type, encoding):
        """Return the CoAP Content Format matching the supplied
           media type (and optional encoding), or None if no
           match can be found."""
        return CoAPContentFormatRegistry.LOOKUP_TABLE.get(
            (media_type, encoding), None)


class LooseMediaTypeMapper(object):
    # Order matters in this table: more specific types have higher rank
    # compared to less specific types.
    # This code only performs a shallow validation of acceptable
    # characters, and assumes overall validation of media type and
    # subtype has been done beforehand.
    LOOKUP_TABLE = [
        (re.compile("application/.+\+xml$"), "application/xml"),
        (re.compile("application/.+\+json$"), "application/json"),
        (re.compile("application/.+\+cbor$"), "application/cbor"),
        (re.compile("text/xml$"), "application/xml"),
        (re.compile("text/[a-z\.\-\+]+$"), "text/plain;charset=utf-8"),
        (re.compile("[a-z]+/[a-z\.\-\+]+$"), "application/octet-stream")
    ]

    def lookup(self, media_type):
        """Return the best loose media type match available using
           the contents of LOOKUP_TABLE."""
        for entry in LooseMediaTypeMapper.LOOKUP_TABLE:
            if entry[0].match(media_type) is not None:
                return entry[1]
        return None


def mt2cf(media_type, encoding=None,
          coap_cf_registry=CoAPContentFormatRegistry(),
          loose_mapper=None):
    """Return a CoAP Content-Format given an Internet Media Type and
       its optional encoding.  The current (as of 2016/10/24) CoAP
       Content Format Registry is supplied by default.  An optional
       'loose-mapping' implementation can be supplied by the caller."""
    assert media_type is not None
    assert coap_cf_registry is not None

    # Lookup the CoAP Content-Formats registry
    content_format = coap_cf_registry.lookup(media_type, encoding)

    # If an exact match is not found and a loose mapper has been
    # supplied, try to use it to get a media type with which to
    # re-try the CoAP Content-Formats registry lookup.
    if content_format is None and loose_mapper is not None:
        content_format = coap_cf_registry.lookup(
            loose_mapper.lookup(media_type), encoding)

    return content_format


class TestMT2CF(unittest.TestCase):

    def testMissingContentType(self):
        with self.assertRaises(AssertionError):
            mt2cf(None)

    def testMissingContentFormatRegistry(self):
        with self.assertRaises(AssertionError):
            mt2cf(None, coap_cf_registry=None)

    def testTextPlain(self):
        self.assertEqual(mt2cf("text/plain;charset=utf-8"),
                         CoAPContentFormatRegistry.TEXT_PLAIN)

    def testLinkFormat(self):
        self.assertEqual(mt2cf("application/link-format"),
                         CoAPContentFormatRegistry.LINK_FORMAT)

    def testXML(self):
        self.assertEqual(mt2cf("application/xml"),
                         CoAPContentFormatRegistry.XML)

    def testOctetStream(self):
        self.assertEqual(mt2cf("application/octet-stream"),
                         CoAPContentFormatRegistry.OCTET_STREAM)

    def testEXI(self):
        self.assertEqual(mt2cf("application/exi"),
                         CoAPContentFormatRegistry.EXI)

    def testJSON(self):
        self.assertEqual(mt2cf("application/json"),
                         CoAPContentFormatRegistry.JSON)

    def testCBOR(self):
        self.assertEqual(mt2cf("application/cbor"),
                         CoAPContentFormatRegistry.CBOR)

    def testCoAPGroupJSON(self):
        self.assertEqual(mt2cf("application/coap-group+json",
                               "utf-8"),
                         CoAPContentFormatRegistry.GROUP_JSON)

    def testUnknownMediaType(self):
        self.assertFalse(mt2cf("unknown/media-type"))

    def testLooseXML1(self):
        self.assertEqual(
            mt2cf(
                "application/somesubtype+xml",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.XML)

    def testLooseXML2(self):
        self.assertEqual(
            mt2cf(
                "text/xml",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.XML)

    def testLooseJSON(self):
        self.assertEqual(
            mt2cf(
                "application/somesubtype+json",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.JSON)

    def testLooseCBOR(self):
        self.assertEqual(
            mt2cf(
                "application/somesubtype+cbor",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.CBOR)

    def testLooseText(self):
        self.assertEqual(
            mt2cf(
                "text/somesubtype",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.TEXT_PLAIN)

    def testLooseUnknown(self):
        self.assertEqual(
            mt2cf(
                "application/somesubtype-of-some-sort+format",
                loose_mapper=LooseMediaTypeMapper()),
            CoAPContentFormatRegistry.OCTET_STREAM)

    def testLooseInvalidStartsWithNonAlpha(self):
        self.assertFalse(
            mt2cf(
                " application/somesubtype",
                loose_mapper=LooseMediaTypeMapper()))

    def testLooseInvalidEndsWithUnexpectedChar(self):
        self.assertFalse(
            mt2cf(
                "application/somesubtype ",
                loose_mapper=LooseMediaTypeMapper()))

    def testLooseInvalidUnexpectedCharInTheMiddle(self):
        self.assertFalse(
            mt2cf(
                "application /somesubtype",
                loose_mapper=LooseMediaTypeMapper()))

    def testLooseInvalidNoSubType1(self):
        self.assertFalse(
            mt2cf(
                "application",
                loose_mapper=LooseMediaTypeMapper()))

    def testLooseInvalidNoSubType2(self):
        self.assertFalse(
            mt2cf(
                "application/",
                loose_mapper=LooseMediaTypeMapper()))

if __name__ == "__main__":
    unittest.main(verbosity=2)
            
          </pre>
<p/>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> Change Log</h1>
<p id="rfc.section.B.p.1">[Note to RFC Editor: Please remove this section before publication.]</p>
<p id="rfc.section.B.p.2">Changes from ietf-16 to ietf-17: </p>

<ul>
  <li>Intended status from Informational to Standards Track;</li>
  <li>Stephen Farrell's DISCUSS</li>
  <li>Added 2.31 and 4.08 CoAP response codes to the Response Code Mapping table.</li>
  <li>Editorial fixes</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.3">Changes from ietf-15 to ietf-16 (Apps-Dir review): </p>

<ul>
  <li>Larry Masinter's comments.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.4">Changes from ietf-14 to ietf-15 (IESG review): </p>

<ul>
  <li>Kathleen Moriarty's DISCUSS and COMMENT;</li>
  <li>Stephen Farrell's COMMENT;</li>
  <li>Suresh Krishnan DISCUSS;</li>
  <li>Spencer Dawkins' DISCUSS and COMMENT;</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.5">Changes from ietf-13 to ietf-14: </p>

<ul>
  <li>Addressed Gen-ART and AD review comments.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.6">Changes from ietf-12 to ietf-13 (Christian Amsuess' comments): </p>

<ul>
  <li>More missing slashes in URI mapping template examples.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.7">Changes from ietf-11 to ietf-12 (2nd WGLC): </p>

<ul>
  <li>Addressed a few editorial issues (including a clarification on when to use qq vs q in the URI mapping template).</li>
  <li>Fixed missing slash in one template example.</li>
  <li>Added para about the need for future CoAP protocol elements to define their own HTTP mappings.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.8">Changes from ietf-10 to ietf-11 (Chair review): </p>

<ul>
  <li>Removed cu/su distinction from the URI mapping template.</li>
  <li>Addressed a few editorial issues.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.9">Changes from ietf-09 to ietf-10: </p>

<ul>
  <li>Addressed Ticket #401 - Clarified that draft covers not only Reverse HC Proxy but that many parts also apply to Forward and Interception Proxies.</li>
  <li>Clarified that draft concentrates on the HTTP-to-CoAP mapping direction (i.e., the HC Proxy is an HTTP server and a CoAP client).</li>
  <li>Clarified the "null mapping" case where no CoAP URI information is embedded in the HTTP request URI.</li>
  <li>Moved multicast related security text to the "Security Considerations" to consolidate all security information in one location.</li>
  <li>Removed references to "placement" of proxy (e.g., server-side vs client-side) as is confusing and provides little added value.</li>
  <li>Fixed version numbers on references that were corrupted in last revision due to outdated xml2rfc conversion tool local cache.</li>
  <li>Various editorial improvements.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.10">Changes from ietf-08 to ietf-09: </p>

<ul>
  <li>Clean up requirements language as per Klaus' comment.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.11">Changes from ietf-07 to ietf-08: </p>

<ul>
  <li>Addressed WGLC review comments from Klaus Hartke as per the correspondence of March 9, 2016 on the CORE WG mailing list. </li>
</ul>

<p> </p>
<p id="rfc.section.B.p.12">Changes from ietf-06 to ietf-07: </p>

<ul>
  <li>Addressed Ticket #384 - Section 5.4.1 describes briefly (informative) how to discover CoAP resources from an HTTP client.</li>
  <li>Addressed Ticket #378 - For HTTP media type to CoAP content format mapping and vice versa: a new draft (TBD) may be proposed in CoRE which describes an approach for automatic updating of the media type mapping.  This was noted in Section 6.1 but is otherwise outside the scope of this draft.</li>
  <li>Addressed Ticket #377 - Added IANA section that defines a new HTTP media type "application/coap-payload" and created new <a href="#sec-application-coap-payload">Section 6.2</a> on how to use it.</li>
  <li>Addressed Ticket #376 - Updated Table 2 (and corresponding note 7) to indicate that a CoAP 4.05 (Method Not Allowed) Response Code should be mapped to an HTTP 400 (Bad Request).</li>
  <li>Added note to comply to ABNF when translating CoAP diagnostic payload to reason-phrase in <a href="#sec-diagnostic">Section 6.5.3</a>.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.13">Changes from ietf-05 to ietf-06: </p>

<ul>
  <li>Fully restructured the draft, bringing introductory text more to the front and allocating main sections to each of the key topics; addressing Ticket #379;</li>
  <li>Addressed Ticket #382, fix of enhanced form URI template definition of q in Section 5.3.2;</li>
  <li>Addressed Ticket #381, found a mapping 4.01 to 401 Unauthorized in Section 7;</li>
  <li>Addressed Ticket #380 (Add IANA registration for "core.hc" Resource Type) in Section 9;</li>
  <li>Addressed Ticket #376 (CoAP 4.05 response can't be translated to HTTP 405 by HC Proxy) in Section 7 by use of empty 'Allow' header;</li>
  <li>Removed details on the pros and cons of HC Proxy placement options;</li>
  <li>Addressed review comments of Carsten Bormann;</li>
  <li>Clarified failure in mapping of HTTP Accept headers (Section 6.3);</li>
  <li>Clarified detection of CoAP servers not supporting blockwise (Section 8.3);</li>
  <li>Changed CoAP request timeout min value to MAX_RTT + MAX_SERVER_RESPONSE_DELAY (Section 8.6);</li>
  <li>Added security section item (Section 10.3) related to use of CoAP blockwise transfers;</li>
  <li>Many editorial improvements.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.14">Changes from ietf-04 to ietf-05: </p>

<ul>
  <li>Addressed Ticket #366 (Mapping of CoRE Link Format payloads to be valid in HTTP Domain?) in Section 6.3.3.2 (Content Transcoding - CORE Link Format);</li>
  <li>Addressed Ticket #375 (Add requirement on mapping of CoAP diagnostic payload) in Section 6.3.3.3 (Content Transcoding - Diagnostic Messages);</li>
  <li>Addressed comment from Yusuke (http://www.ietf.org/mail-archive/web/core/current/msg05491.html) in Section 6.3.3.1 (Content Transcoding - General);</li>
  <li>Various editorial improvements.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.15">Changes from ietf-03 to ietf-04: </p>

<ul>
  <li>Expanded use case descriptions in Section 4;</li>
  <li>Fixed/enhanced discovery examples in Section 5.4.1;</li>
  <li>Addressed Ticket #365 (Add text on media type conversion by HTTP-CoAP proxy) in new Section 6.3.1 (Generalized media type mapping) and new Section 6.3.2 (Content translation);</li>
  <li>Updated HTTPBis WG draft references to recently published RFC numbers.</li>
  <li>Various editorial improvements.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.16">Changes from ietf-02 to ietf-03: </p>

<ul>
  <li>Closed Ticket #351 "Add security implications of proposed default HTTP-CoAP URI mapping";</li>
  <li>Closed Ticket #363 "Remove CoAP scheme in default HTTP-CoAP URI mapping";</li>
  <li>Closed Ticket #364  "Add discovery of HTTP-CoAP mapping resource(s)".</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.17">Changes from ietf-01 to ietf-02: </p>

<ul>
  <li>Selection of single default URI mapping proposal as proposed to WG mailing list 2013-10-09.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.18">Changes from ietf-00 to ietf-01: </p>

<ul>
  <li>Added URI mapping proposals to Section 4 as per the Email proposals to WG mailing list from Esko.</li>
</ul>

<p> </p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Angelo P. Castellani</span> 
	  <span class="n hidden">
		<span class="family-name">Castellani</span>
	  </span>
	</span>
	<span class="org vcardline">University of Padova</span>
	<span class="adr">
	  <span class="vcardline">Via Gradenigo 6/B</span>

	  <span class="vcardline">
		<span class="locality">Padova</span>,  
		<span class="region"></span>
		<span class="code">35131</span>
	  </span>
	  <span class="country-name vcardline">Italy</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:angelo@castellani.net">angelo@castellani.net</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Salvatore Loreto</span> 
	  <span class="n hidden">
		<span class="family-name">Loreto</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson</span>
	<span class="adr">
	  <span class="vcardline">Hirsalantie 11</span>

	  <span class="vcardline">
		<span class="locality">Jorvas</span>,  
		<span class="region"></span>
		<span class="code">02420</span>
	  </span>
	  <span class="country-name vcardline">Finland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:salvatore.loreto@ericsson.com">salvatore.loreto@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Akbar Rahman</span> 
	  <span class="n hidden">
		<span class="family-name">Rahman</span>
	  </span>
	</span>
	<span class="org vcardline">InterDigital Communications, LLC</span>
	<span class="adr">
	  <span class="vcardline">1000 Sherbrooke Street West</span>

	  <span class="vcardline">
		<span class="locality">Montreal</span>,  
		<span class="region"></span>
		<span class="code">H3A 3G4</span>
	  </span>
	  <span class="country-name vcardline">Canada</span>
	</span>
	<span class="vcardline">Phone: +1 514 585 0761</span>

<span class="vcardline">EMail: <a href="mailto:Akbar.Rahman@InterDigital.com">Akbar.Rahman@InterDigital.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Thomas Fossati</span> 
	  <span class="n hidden">
		<span class="family-name">Fossati</span>
	  </span>
	</span>
	<span class="org vcardline">Nokia</span>
	<span class="adr">
	  <span class="vcardline">3 Ely Road</span>

	  <span class="vcardline">
		<span class="locality">Milton, Cambridge</span>,  
		<span class="region"></span>
		<span class="code">CB24 6DD</span>
	  </span>
	  <span class="country-name vcardline">UK</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:thomas.fossati@nokia.com">thomas.fossati@nokia.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Esko Dijk</span> 
	  <span class="n hidden">
		<span class="family-name">Dijk</span>
	  </span>
	</span>
	<span class="org vcardline">Philips Lighting</span>
	<span class="adr">
	  <span class="vcardline">High Tech Campus 7</span>

	  <span class="vcardline">
		<span class="locality">Eindhoven</span>,  
		<span class="region"></span>
		<span class="code">5656 AE</span>
	  </span>
	  <span class="country-name vcardline">The Netherlands</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:esko.dijk@philips.com">esko.dijk@philips.com</a></span>

  </address>
</div>

</body>
</html>
